version: "3.8"

services:
  rabbitmq:
    build:
      context: ./rabbitmq
      dockerfile: Dockerfile # or use image: rabbitmq:3.13-management if definitions.json is the only custom part
    container_name: rabbitmq_bus_global
    ports:
      - "5672:5672"
      - "15672:15672"
    volumes:
      - ./rabbitmq/definitions.json:/etc/rabbitmq/definitions.json
    environment:
      RABBITMQ_DEFAULT_USER: admin
      RABBITMQ_DEFAULT_PASS: admin123
    healthcheck:
      test: ["CMD", "rabbitmqctl", "status"]
      interval: 30s
      timeout: 10s
      retries: 5

  postgres_db:
    build:
      context: ./java # Assuming Dockerfile for postgres is not needed, using image directly
      # but db.sql is in ./java. So, this is slightly unconventional.
      # Better to define postgres within java/docker-compose.yml and extend here,
      # or duplicate definition. For simplicity, duplicating relevant parts.
    image: postgres:16-alpine
    container_name: bd1_postgres_global
    environment:
      POSTGRES_USER: lp1_user
      POSTGRES_PASSWORD: lp1_password
      POSTGRES_DB: bd1_users
    volumes:
      - ./java/db.sql:/docker-entrypoint-initdb.d/init.sql
      - postgres_data_global:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB} -h localhost",
        ]
      interval: 10s
      timeout: 5s
      retries: 5

  mariadb_db:
    image: mariadb:11
    container_name: bd2_mariadb_global
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_DATABASE: bd2_dni
      MYSQL_USER: lp2_user
      MYSQL_PASSWORD: lp2_password
    volumes:
      - ./python/db.sql:/docker-entrypoint-initdb.d/init.sql
      - mariadb_data_global:/var/lib/mysql
    ports:
      - "3306:3306"
    healthcheck:
      test:
        [
          "CMD",
          "mariadb-admin",
          "ping",
          "-h",
          "localhost",
          "-u$${MYSQL_USER}",
          "-p$${MYSQL_PASSWORD}",
        ]
      interval: 10s
      timeout: 5s
      retries: 5

  lp1_app:
    build:
      context: ./java
      dockerfile: Dockerfile
    container_name: lp1_persister_app_global
    depends_on:
      postgres_db:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
    ports:
      - "8081:8080"
    environment:
      DB_HOST: postgres_db
      DB_PORT: 5432
      DB_NAME: bd1_users
      DB_USER: lp1_user
      DB_PASSWORD: lp1_password
      RABBITMQ_HOST: rabbitmq
      RABBITMQ_PORT: 5672
      RABBITMQ_USER: admin
      RABBITMQ_PASS: admin123
      RABBITMQ_QUEUE_PERSIST: queue_lp1
      RABBITMQ_EXCHANGE: registro_bus
      RABBITMQ_ROUTING_KEY_PERSISTED: lp1.persisted

  lp2_app:
    build:
      context: ./python
      dockerfile: Dockerfile
    container_name: lp2_validator_app_global
    depends_on:
      mariadb_db:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
    ports:
      - "8082:8080"
    environment:
      DB_HOST: mariadb_db
      DB_PORT: 3306
      DB_NAME: bd2_dni
      DB_USER: lp2_user
      DB_PASSWORD: lp2_password
      RABBITMQ_HOST: rabbitmq
      RABBITMQ_PORT: 5672
      RABBITMQ_USER: admin
      RABBITMQ_PASS: admin123
      RABBITMQ_QUEUE_VALIDATE: queue_lp2
      RABBITMQ_EXCHANGE: registro_bus
      RABBITMQ_ROUTING_KEY_OK: lp2.query.ok
      RABBITMQ_ROUTING_KEY_FAIL: lp2.query.fail

  lp3_app:
    build:
      context: ./node
      dockerfile: Dockerfile
    container_name: lp3_client_app_global
    depends_on:
      rabbitmq:
        condition: service_healthy
      # LP3 might not directly depend on LP1/LP2 being up, only RabbitMQ
      # lp1_app:
      #   condition: service_started # or service_healthy if LP1 has healthcheck
      # lp2_app:
      #   condition: service_started # or service_healthy if LP2 has healthcheck
    ports:
      - "8083:8083"
    environment:
      RABBITMQ_HOST: rabbitmq
      RABBITMQ_PORT: 5672
      RABBITMQ_USER: admin
      RABBITMQ_PASS: admin123
      RABBITMQ_EXCHANGE: registro_bus
      RABBITMQ_QUEUE_SIGNUP: lp3.signup
      RABBITMQ_QUEUE_ACK: queue_lp3_ack
      RABBITMQ_ROUTING_KEY_SIGNUP: lp3.signup
      RABBITMQ_ROUTING_KEY_ACK: lp3.ack
      APP_PORT: 8083
      # Potentially, URLs for LP1/LP2 if LP3 needs to directly ping them for health/stats, though unlikely with RabbitMQ focus
      # LP1_URL: http://lp1_app:8080
      # LP2_URL: http://lp2_app:8080

volumes:
  postgres_data_global:
  mariadb_data_global:
